---
title: "05 - React JS: Using hooks"
categories: [React JS, Hooks]
author: ProtossGP32
date: 2023/04/26
from: markdown+emoji
---
# Introduction


# Types of hooks
## `useState`

## `useReducer`
A reducer is a function takes in the current state of an application and an action, and returns a new state. Reducers are often used in conjunction with a state manager library like `Redux`, which helps manage the state of a React application.

### Initialization
`useReducer` is a hook with the following parameters:

```{.js}
useReducer(reducer, intialArg, init?)
```

- `reducer`: function that specifies how the state gets updated
    - It must be pure, should take the state and action as arguments, and should return the next state
    - State and action can be of any types
- `initialArg`: value from which the initial state is calculated
    - It can be a value of any type
    - Calculation of the initial state depends on the next `init` argument
- `[optional] init`: initializer function that specifies how the initial state is calculated
    - If not specified, initial state is set to `initialArg`
    - Otherwise, initial state is set to the result of calling `init(initialArg)`

It is very similar to `useState` but it lets you move the state update logic from event handlers into a single function outside of your component.

### Dispatch function
`useReducer` returns an array with exactly two values:

- **The current state:** During the first render, it's set to `init(initialArg)` or `initialArg` (if there's no `init`)
- **The `dispatch` function** that lets you update the state to a different value and trigger a re-render
    - You need to pass the action as the only argument to the `dispatch` function
    - `dispatch` function doesn't return anything

### Example 1
Take this `useReducer` implementation as an example:

```{.js filename="useReducer example"}
import { useReducer } from 'react';

function reducer(state, action) {
  if (action.type === 'incremented_age') {
    return {
      age: state.age + 1
    };
  }
  throw Error('Unknown action.');
};

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, { age: 42 });

  return (
    <>
      <button onClick={() => {
        dispatch({ type: 'incremented_age' })
      }}>
        Increment age
      </button>
      <p>Hello! You are {state.age}.</p>
    </>
  );
};
```
Let's analyse it:

- `reducer`: the reducer manages a state object with one field, `age`
    - If the `action` received is `incremented_age`, then it update the `age` value of the current state and returns a whole new state (take note of the JSON object returned with the `age` key inside)
    - Else, throw an exception as the received action is unknown to the function
- `dispatch`: the trigger of the `useReducer` hook
    - It is called upon a button `onClick` method
    - A JSON object with a single `type` key is passed to the function; this is the `action` that the `reducer` receives along the current state

### Example 2
:::{.callout-warning}
## TODO: copy the example 2 from [here](https://albertprofe.dev/reactjs/reactjs-hook-reducer.html)
:::


### Example 3 - PersonForm

```{.js filename="PersonForm.jsx" include="../../../../react-exercises/lab-re02-1/src/components/PersonForm/index.jsx"}

```

## `useRef`

## `useEffect`

> [**Official docs:**](https://react.dev/learn/synchronizing-with-effects)

`useEffect` is a hook that **doesn't depend on its component's render lifecycle**.

### Parameters
`useEffect` accepts two arguments. The second argument is optional.

```{.js}
useEffect(setup, dependencies)
```
where:

- `setup`: function with the `effect`'s logic
  - This function may also optionally return a clean-up function
  - When the component is first added to the DOM, React will run the setup function
  - After every re-render with **changed dependencies**, React will first run the clean-up function (when provided) with the old values, and then run the setup function with the new values
  - Once the component is removed from the DOM, React will run your cleanup function one last time
- `(optional) dependencies`: list of all reactive values referenced inside the setup code
  - Reactive values include props, state and all the variables and functions declared directly inside your component body
  - These are the ones that trigger the `useEffect`: when no dependencies are defined, the `useEffect` is triggered...
  - Dependency array properties:
    - **Optional:** if not specified, `useEffect` runs after each render
    - **Empty array:** then the `useEffect` runs once after the initial render

### Example 1
Let's see an example:

```{.js filename="App.js"}
import { useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  // Define a useState to manage the serverUrl
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');
  // Define a useEffect to manage connections to the ChatRoom
  useEffect(() => {
      const connection = createConnection(serverUrl, roomId);
      connnection.connect();
      return () => {
        connection.disconnect();
      };
    }, [serverUrl, roomId]); // Dependencies are both the serverUrl and roomId
  // Do something else...
}
```
where:

- `setup` function creates the connection to the `serverUrl` and a specified `roomId`
- `dependencies` here are both the `serverUrl` and the `roomId`, meaning that if any of them


### Example 2
Another example:

```{.js}
import React, { useState, useEffect } from "react";

const App = () => {
  // Define a useState to control the message state
  const [message, setMessage] = useState("Hi there, how are you?");
  // Define a useEffect to change the message value
  useEffect(() => {
      // Each time a dependency changes, useEffect will launch the setTimeout
      // Wait for 6 secs and then change the message
      setTimeout(() => {
        setMessage("I'm fine, thanks!");
      }, 6000);
  }, []);

  return <h1>{message}</h1>;
};

export default App;
```

:::{.callout-warning}
## TODO: explain this example
:::

### Synchronizing with Effects
:::{.callout-tip}
## Synchronize is a key-word
> The question is not 'when does this effect run', the question is 'with which state does this effect synchronize'
- Ryan Florence
:::

## `useContext`

## Custom hooks

# Basic hooks rules
## Only call hooks at the top level
## Only call hooks from React Functions

